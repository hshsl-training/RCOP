[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "NNLM + CDABS R Community of Practice",
    "section": "",
    "text": "Objective:\nThe objective of this website is to provide supporting documentation for R Community of Practice. In the navigation bar you will find each week lesson.\nWeekly Topics\n\n\n\n\n\n\n\n\nWeek\nTopic\nSlides\n\n\n\n\nWeek 1\nReading multiple files\nWeek 1\n\n\nWeek 2\nWorking with Dates\nWeek 2\n\n\nWeek 3\nCreating a bar chart with ggplot2\n\n\n\nWeek 4\nTransforming data from wide to long\n\n\n\nWeek 5\nAccessing NCBI data with the Rentrez package\n\n\n\nWeek 6\nCommunicating with Quarto\n\n\n\n\nDownload the data by week for all the lessons here."
  },
  {
    "objectID": "Week01/week01_lesson.html",
    "href": "Week01/week01_lesson.html",
    "title": "R Community of Practice Week 1",
    "section": "",
    "text": "In introductory R classes we learn how to import data by reading one file at a time. This week, we will “level up” our R skills by learning how to important multiple files at once. This can be especially useful when you have several files with a similar structure and want to be able to combine and analyze them together. To accomplish this goal, we’ll be working with a new data structure called a list and learning how to iterate over that list."
  },
  {
    "objectID": "Week01/week01_lesson.html#the-data",
    "href": "Week01/week01_lesson.html#the-data",
    "title": "R Community of Practice Week 1",
    "section": "The Data",
    "text": "The Data\nDownload the data for this lesson here.\nOur scenario this week is that we have a folder of registration data for workshops that we want to combine and analyze. We have a separate spreadsheet for each workshop with a list of attendees, their affiliations, and status. This data has been generated and does not contain any names or information of actual workshop participants, but is based on the structure of registration data we use here at UMB.\nLet’s load the packages we’ll be working with today.\n\nlibrary(tidyverse)\nlibrary(fs)"
  },
  {
    "objectID": "Week01/week01_lesson.html#review---importing-data",
    "href": "Week01/week01_lesson.html#review---importing-data",
    "title": "R Community of Practice Week 1",
    "section": "Review - Importing data",
    "text": "Review - Importing data\nTo import one csv file, we can use the function read_csv() from the readr package, part of the tidyverse. You can also use the Import Dataset widget in the RStudio GUI.\n\nWorkshop01 <- read_csv(\"data/Workshop_01.csv\")"
  },
  {
    "objectID": "Week01/week01_lesson.html#the-power-of-iteration",
    "href": "Week01/week01_lesson.html#the-power-of-iteration",
    "title": "R Community of Practice Week 1",
    "section": "The Power of Iteration",
    "text": "The Power of Iteration\nTo read in multiple files, we could copy and paste that code a bunch of times with different names each time.\n\nWorkshop02 <- read_csv(\"data/Workshop_02.csv\")\n\nWorkshop03 <- read_csv(\"data/Workshop_03.csv\")\n\nWorkshop04 <- read_csv(\"data/Workshop_04.csv\")\n\nBut! That’s a really good way to make mistakes, and part of the benefit of learning to code is to avoid the need to repeat things. Most programming languages, including R, have ways of iterating, or repeating, an operation over multiple objects based on some instructions. Often this iteration takes place in some kind of loop operation, e.g.\nfor (thing in list_of_things) {\n  do_some_function()\n}\nThese can be used in R, but it is more common to use one of several available R functions for this task.\nWe’ll use a function called map() which takes as arguments a vector or list (.x) and a function (.f) we will use to iterate over the elements of that vector or list. So the syntax of this function is map(.x, .f).\nSo, we have our function read_csv(), and now we want it to repeat for all the file names in our directory. So - how do we accomplish this?\n\nCreate a vector of file names\nUse map() to run read_csv() on each file name.\nCombine files into one data frame.\nSummarize data frame"
  },
  {
    "objectID": "Week01/week01_lesson.html#step-1-create-a-vector-of-file-names",
    "href": "Week01/week01_lesson.html#step-1-create-a-vector-of-file-names",
    "title": "R Community of Practice Week 1",
    "section": "Step 1: Create a vector of file names",
    "text": "Step 1: Create a vector of file names\nFirst, you’ll want to have all the files you need saved in the same directory. Then we can use the base R function list.files() on that directory. We’ll save this an object so we can use this later.\n\nfiles <- list.files(\"data/\", full.names = TRUE)\n\nfiles\n\n [1] \"data//Workshop_01.csv\" \"data//Workshop_02.csv\" \"data//Workshop_03.csv\"\n [4] \"data//Workshop_04.csv\" \"data//Workshop_05.csv\" \"data//Workshop_06.csv\"\n [7] \"data//Workshop_07.csv\" \"data//Workshop_08.csv\" \"data//Workshop_09.csv\"\n[10] \"data//Workshop_10.csv\""
  },
  {
    "objectID": "Week01/week01_lesson.html#step-2-iterate-over-file-names",
    "href": "Week01/week01_lesson.html#step-2-iterate-over-file-names",
    "title": "R Community of Practice Week 1",
    "section": "Step 2: Iterate over file names",
    "text": "Step 2: Iterate over file names\nAs mentioned before, now we have an object to stand in for the .x argument of map()\n\nworkshop_list <- map(files, read_csv)"
  },
  {
    "objectID": "Week01/week01_lesson.html#step-3-combine-into-one-data-frame",
    "href": "Week01/week01_lesson.html#step-3-combine-into-one-data-frame",
    "title": "R Community of Practice Week 1",
    "section": "Step 3: Combine into one data frame",
    "text": "Step 3: Combine into one data frame\n\nWorking with lists\nAfter running our last step, the resulting object is in a structure called a list. In most beginning R workshops we work with two main data structures: vectors and data frames\n\nR Data Structures\n\n\n\nhomogeneous\nheterogenous\n\n\n\n\n1d\nvector\nlist\n\n\n2d\nmatrix\ndata frame\n\n\nnd\narray\n\n\n\n\nLists are made up of elements like vectors, but those elements can be anything. Often we use lists to work with several data frames at one time.\n\n\nAdding names to lists\nEach element of the list is given an index number. But it will be helpful to us to give the elements names. We do this with the names() function.\n\nnames(workshop_list) #currently no names\n\nNULL\n\n\nLet’s name each element the same as the file, this way when we combine the data, we can keep track of which rows came from which data frame. We’ll use the fs package which contains tools for working with file names.\n\npath_file(files) # keeps only file part of path\n\n [1] \"Workshop_01.csv\" \"Workshop_02.csv\" \"Workshop_03.csv\" \"Workshop_04.csv\"\n [5] \"Workshop_05.csv\" \"Workshop_06.csv\" \"Workshop_07.csv\" \"Workshop_08.csv\"\n [9] \"Workshop_09.csv\" \"Workshop_10.csv\"\n\npath_ext_remove(files) #keeps just \n\n [1] \"data/Workshop_01\" \"data/Workshop_02\" \"data/Workshop_03\" \"data/Workshop_04\"\n [5] \"data/Workshop_05\" \"data/Workshop_06\" \"data/Workshop_07\" \"data/Workshop_08\"\n [9] \"data/Workshop_09\" \"data/Workshop_10\"\n\nnames(workshop_list) <-path_ext_remove(path_file(files))\n\nnames(workshop_list)\n\n [1] \"Workshop_01\" \"Workshop_02\" \"Workshop_03\" \"Workshop_04\" \"Workshop_05\"\n [6] \"Workshop_06\" \"Workshop_07\" \"Workshop_08\" \"Workshop_09\" \"Workshop_10\"\n\n\n\n\nBinding rows\nWe’ll use the bind_rows() function from dplyr to paste each element in our list into one data frame. The .id argument will allow us to keep track of which row came from which original dataset. It uses the names of the list elements as values.\n\nall_workshops <- bind_rows(workshop_list, .id = \"Workshop\") %>% \n  arrange(attendees)\n\n\n\nhead(all_workshops)\n\n# A tibble: 6 × 4\n  Workshop    attendees                affiliation status \n  <chr>       <chr>                    <chr>       <chr>  \n1 Workshop_06 Abdul Waahid al-Jaber    Nursing     Faculty\n2 Workshop_10 Addison Elkins           Graduate    Staff  \n3 Workshop_07 Adriana Picazo           Medicine    Staff  \n4 Workshop_05 Alexander Garcia-Marrufo Nursing     Faculty\n5 Workshop_09 Alexandra Willis         Social Work Staff  \n6 Workshop_06 Alexis Wright            Medicine    Faculty"
  },
  {
    "objectID": "Week01/week01_lesson.html#step-4-summarize-the-data",
    "href": "Week01/week01_lesson.html#step-4-summarize-the-data",
    "title": "R Community of Practice Week 1",
    "section": "Step 4: Summarize the data",
    "text": "Step 4: Summarize the data\nNow we can work with our data in the more familiar structure of a data frame. This allows us to do things like get a count of how many of each affiliation and status attended all workshops put together.\n\nall_workshops %>% \n  count(affiliation)\n\n# A tibble: 6 × 2\n  affiliation     n\n  <chr>       <int>\n1 Dentistry      21\n2 Graduate       25\n3 Medicine       30\n4 Nursing        35\n5 Pharmacy       31\n6 Social Work    31\n\nall_workshops %>% \n  count(status)\n\n# A tibble: 3 × 2\n  status      n\n  <chr>   <int>\n1 Faculty    62\n2 Staff      60\n3 Student    51"
  },
  {
    "objectID": "Week01/week01_lesson.html#wrapping-up",
    "href": "Week01/week01_lesson.html#wrapping-up",
    "title": "R Community of Practice Week 1",
    "section": "Wrapping up",
    "text": "Wrapping up\nWe might want to work with this data again later so let’s be sure to save it. We can write it back out to a CSV file, or we can save it directly as an R object. Let’s try both ways and save these to our data_outputs folder.\n\nworkshop_breakdown <- \n  all_workshops %>% \n  count(affiliation, status)\n\nsaveRDS(all_workshops, \"data_output/all_workshops.RDS\")\n\nsaveRDS(workshop_breakdown, \"data_output/workshop_breakdown.RDS\")"
  },
  {
    "objectID": "Week02/week02_lesson.html",
    "href": "Week02/week02_lesson.html",
    "title": "R Community of Practice Week 2",
    "section": "",
    "text": "Dates are a particular kind of numeric data type in R. Dates can be tricky to work for a couple of reasons. Often when you import data into R, it will interpret dates as strings, or character data type. This will make things difficult if you want to do calculations with dates, or parse out a part of a date. Second, time units are often variable, months have different numbers of days, there are leap years, and time zones can be another factor to consider. In this lesson, we’ll be introducing the lubridate package, which is part of the tidyverse, and makes working with dates much more manageable."
  },
  {
    "objectID": "Week02/week02_lesson.html#the-data",
    "href": "Week02/week02_lesson.html#the-data",
    "title": "R Community of Practice Week 2",
    "section": "The Data",
    "text": "The Data\nDownload the data for this lesson here.\nOur scenario this week is that we a spreadsheet of data tracking research consults from 2018 to 2023. We want to accomplish the following tasks:\n\nChange the date variable to date data type\nSummarize the number of consults by month and year\nFilter the data to look at just FY2022\n\nLet’s open a new script and load the libraries we’ll be working with in this lesson:\n\nlibrary(tidyverse)\n\nAnd now we can import our data set\n\nconsults <- read_csv(\"data/consults.csv\")"
  },
  {
    "objectID": "Week02/week02_lesson.html#step-1-changing-strings-to-dates",
    "href": "Week02/week02_lesson.html#step-1-changing-strings-to-dates",
    "title": "R Community of Practice Week 2",
    "section": "Step 1: Changing Strings to Dates",
    "text": "Step 1: Changing Strings to Dates\nHow do we know what kind of data our date variable is? We use the class() function to check data types\n\nclass(consults$date)\n\n[1] \"character\"\n\n\nLet’s change that to date data type. lubridate has a number of functions for parsing dates in different formats. The name of the function depends on the format of the input date.\nFor example, if we had a string with date in the month, day, year format, we would use the mdy() function.\n\nmyDate <- \"June 22, 2023\"\n\nmyRealDate <- mdy(myDate)\n\nclass(myDate)\n## [1] \"character\"\nclass(myRealDate)\n## [1] \"Date\"\n\nOr, as another example:\n\nmyDate <- \"22062023\"\nmyRealDate <- dmy(myDate)\n\nclass(myDate)\n## [1] \"character\"\nclass(myRealDate)\n## [1] \"Date\"\n\nand finally\n\nmyDate <- \"2023-06-22\"\nmyRealDate <- ymd(myDate)\n\nclass(myDate)\n## [1] \"character\"\nclass(myRealDate)\n## [1] \"Date\"\n\nNow that we have a better idea of how these functions work, we can use them to overwrite our original date column with one that is properly recognized as a date. We use the mutate() function from dplyr to create a new variable.\n\nconsults <- consults %>% \n  mutate(date = mdy(date))\n\nAnd let’s check if that worked\n\nclass(consults$date)\n\n[1] \"Date\""
  },
  {
    "objectID": "Week02/week02_lesson.html#step-2-summarize-data-by-month-and-year",
    "href": "Week02/week02_lesson.html#step-2-summarize-data-by-month-and-year",
    "title": "R Community of Practice Week 2",
    "section": "Step 2: Summarize data by month and year",
    "text": "Step 2: Summarize data by month and year\nAnother set of functions in lubridate help with extracting pieces of dates.\nFor example:\n\nyear(myRealDate)\n## [1] 2023\nmonth(myRealDate)\n## [1] 6\nday(myRealDate)\n## [1] 22\nwday(myRealDate)\n## [1] 5\n\nLet’s summarize the total number of consults for each year in our data set.\n\nconsults_yearly <- consults %>% \n  count(year=year(date), name=\"total_consults\")\n\nconsults_yearly\n\n# A tibble: 6 × 2\n   year total_consults\n  <dbl>          <int>\n1  2018            631\n2  2019            639\n3  2020            463\n4  2021            415\n5  2022            381\n6  2023            141"
  },
  {
    "objectID": "Week02/week02_lesson.html#step-3-working-with-intervals",
    "href": "Week02/week02_lesson.html#step-3-working-with-intervals",
    "title": "R Community of Practice Week 2",
    "section": "Step 3: Working with intervals",
    "text": "Step 3: Working with intervals\nNow, what if we wanted to take a look at the data for just the last fiscal year? How can we filter our data set to include just the dates we want to look at.\nlubridate can work with three types of time spans:\n\ndurations- measure physical time in seconds\nperiods – take into account human variations in time due to varying lengths of months, leap years, etc.\nintervals – timespan defined with a start and end time\n\nFirst we’ll create an interval object.\n\nfy2022 <- interval(mdy(\"07/01/2021\"), mdy(\"06/30/2022\"))\n\nNow we can keep just those consults within our desired time frame.\n\nconsults_fy2022 <-\n  consults %>% \n  filter(date %within% fy2022)\n\nAnd we can summarize these consults by month.\n\nconsults_fy22_monthly <- consults_fy2022 %>% \n count(year=year(date), month=month(date), name = \"total_consults\")\n\nconsults_fy22_monthly\n\n# A tibble: 12 × 3\n    year month total_consults\n   <dbl> <dbl>          <int>\n 1  2021     7             31\n 2  2021     8             13\n 3  2021     9             39\n 4  2021    10             65\n 5  2021    11             16\n 6  2021    12              8\n 7  2022     1             16\n 8  2022     2             62\n 9  2022     3             42\n10  2022     4             18\n11  2022     5             18\n12  2022     6             32"
  },
  {
    "objectID": "Week02/week02_lesson.html#wrapping-up",
    "href": "Week02/week02_lesson.html#wrapping-up",
    "title": "R Community of Practice Week 2",
    "section": "Wrapping Up",
    "text": "Wrapping Up\nOnce again, let’s save these our objects of summarized data to our data_output folder.\n\nsaveRDS(consults_yearly, \"data_output/consults_yearly.RDS\")\n\nsaveRDS(consults_fy22_monthly, \"data_output/consults_fy22_monthly.RDS\")"
  },
  {
    "objectID": "Week01/week01_slides.html",
    "href": "Week01/week01_slides.html",
    "title": "R Community of Practice",
    "section": "",
    "text": "Download the data for this lesson here."
  },
  {
    "objectID": "Week01/week01_slides.html#the-data",
    "href": "Week01/week01_slides.html#the-data",
    "title": "R Community of Practice",
    "section": "The Data",
    "text": "The Data\nScenario: we want to combine and analyze several spreadsheets containing workshop registration data. Each spreadsheet has the same structure - name of attendee 1, school affiliation, and status (faculty, student, staff).\n\n\n\ndata\n├── Workshop_01.csv\n├── Workshop_02.csv\n├── Workshop_03.csv\n├── Workshop_04.csv\n├── Workshop_05.csv\n├── Workshop_06.csv\n├── Workshop_07.csv\n├── Workshop_08.csv\n├── Workshop_09.csv\n└── Workshop_10.csv\n\n\nNote: This data has been generated and contains no real personally identifiable information."
  },
  {
    "objectID": "Week01/week01_slides.html#loops",
    "href": "Week01/week01_slides.html#loops",
    "title": "R Community of Practice",
    "section": "Loops",
    "text": "Loops\nLoops are used in most programming languages when you want to repeat some set of code for multiple inputs.\n\nfor (thing in list_of_things) {\n  do_some_function()\n}"
  },
  {
    "objectID": "Week01/week01_slides.html#functional-programming-in-r",
    "href": "Week01/week01_slides.html#functional-programming-in-r",
    "title": "R Community of Practice",
    "section": "Functional Programming in R",
    "text": "Functional Programming in R\nIn R, there are several functions that accomplish the same thing as loops, in particular:\n\nThe apply() family of functions in Base R\nThe map() family of functions from the purrr package in the tidyverse\n\nmap(.x, .f)\n\nmap(function-args, function)"
  },
  {
    "objectID": "Week01/week01_slides.html#next-steps",
    "href": "Week01/week01_slides.html#next-steps",
    "title": "R Community of Practice",
    "section": "Next Steps",
    "text": "Next Steps\nSo, we have our function read_csv(), and now we want it to repeat for all the file names in our directory. So - how do we accomplish this?\n\nCreate a vector of file names\nUse map() to run read_csv() on each file name.\nCombine files into one data frame.\nSummarize data frame"
  },
  {
    "objectID": "Week01/week01_slides.html#working-with-lists",
    "href": "Week01/week01_slides.html#working-with-lists",
    "title": "R Community of Practice",
    "section": "Working with lists",
    "text": "Working with lists\n\n\n\nLike vectors, lists are made up of elements, but those elements can be anything.\nOften we use lists to work with several data frames at one time.\n\n\n\nR Data Structures 1\n\n\n\nhomogeneous\nheterogenous\n\n\n\n\n1d\nvector\nlist\n\n\n2d\nmatrix\ndata frame\n\n\nnd\narray\n\n\n\n\n\n\n\n\n\n\nFig from Advanced R by Hadley Wickham"
  },
  {
    "objectID": "Week01/week01_slides.html#learning-goals",
    "href": "Week01/week01_slides.html#learning-goals",
    "title": "R Community of Practice",
    "section": "Learning Goals",
    "text": "Learning Goals\n\nimport multiple files into RStudio at a time\nuse tools for working with directories and file paths\nbecome familiar with concept of iteration\nunderstand how to work with a list structure"
  },
  {
    "objectID": "Week02/week02_slides.html#learning-goals",
    "href": "Week02/week02_slides.html#learning-goals",
    "title": "R Community of Practice",
    "section": "Learning Goals",
    "text": "Learning Goals\n\n\nunderstand the challenges of working with dates in R\nbecome familiar with the capabilities of the lubridate package\nuse lubridate to filter and summarize data by date"
  },
  {
    "objectID": "Week02/week02_slides.html#challenges-of-working-with-dates",
    "href": "Week02/week02_slides.html#challenges-of-working-with-dates",
    "title": "R Community of Practice",
    "section": "Challenges of Working with Dates",
    "text": "Challenges of Working with Dates\n\n\ninterpreted as strings when imported to R\nmany date formats\ninconsistent time units (e.g. months, leap years, time zones)"
  },
  {
    "objectID": "Week02/week02_slides.html#the-data",
    "href": "Week02/week02_slides.html#the-data",
    "title": "R Community of Practice",
    "section": "The Data",
    "text": "The Data\nScenario: we have a spreadsheet of data tracking research consults from 2018 to 2023. We want to accomplish the following tasks:\n\n\nChange the date variable to date data type\nSummarize the number of consults by year\nSummarize consults by month for FY2022"
  },
  {
    "objectID": "Week02/week02_slides.html#lubridate-time-spans",
    "href": "Week02/week02_slides.html#lubridate-time-spans",
    "title": "R Community of Practice",
    "section": "Lubridate Time Spans",
    "text": "Lubridate Time Spans\n\ndurations - measure physical time in seconds\nperiods – take into account human variations in time due to varying lengths of months, leap years, etc.\nintervals – time span defined with a start and end time"
  },
  {
    "objectID": "Week02/week02_slides.html",
    "href": "Week02/week02_slides.html",
    "title": "R Community of Practice",
    "section": "",
    "text": "Download the data for this lesson here."
  },
  {
    "objectID": "Week01/week01_lesson.html#introduction",
    "href": "Week01/week01_lesson.html#introduction",
    "title": "Reading multiple files",
    "section": "Introduction",
    "text": "Introduction\nIn introductory R classes we learn how to import data by reading one file at a time. This week, we will “level up” our R skills by learning how to important multiple files at once. This can be especially useful when you have several files with a similar structure and want to be able to combine and analyze them together. To accomplish this goal, we’ll be working with a new data structure called a list and learning how to iterate over that list."
  },
  {
    "objectID": "Week02/week02_lesson.html#introduction",
    "href": "Week02/week02_lesson.html#introduction",
    "title": "Working with Dates",
    "section": "Introduction",
    "text": "Introduction\nDates are a particular kind of numeric data type in R. Dates can be tricky to work for a couple of reasons. Often when you import data into R, it will interpret dates as strings, or character data type. This will make things difficult if you want to do calculations with dates, or parse out a part of a date. Second, time units are often variable, months have different numbers of days, there are leap years, and time zones can be another factor to consider. In this lesson, we’ll be introducing the lubridate package, which is part of the tidyverse, and makes working with dates much more manageable."
  },
  {
    "objectID": "Week03/week03_lesson.html",
    "href": "Week03/week03_lesson.html",
    "title": "R Community of Practice Week 3",
    "section": "",
    "text": "This week we will learn about ggplot2 - a tidyverse package for visualizing data. It is a powerful and flexible tool that allows you to create fully customizable, publication quality graphics. The gg in ggplot2 stands for grammar of graphics. The grammar of graphics is the underlying philosophy of the package. It focuses on creating graphics in layers. Start with the data – map the data the axes and to aesthetic qualities like size, shape, and color and geometries like dots, lines, and polygons. Further refine the appearance of your plot by adjusting scales and legends, labels, coordinate systems, and adding annotations."
  },
  {
    "objectID": "Week03/week03_lesson.html#the-data",
    "href": "Week03/week03_lesson.html#the-data",
    "title": "R Community of Practice Week 3",
    "section": "The Data",
    "text": "The Data\nThe data we’re working with this week is familiar. We’ll visualize the workshops data frames we created in Week 1.\nBecause we saved that data as .RDS files, we can open them up and load them to our environment.\n\nall_workshops <- readRDS(file = \"data/all_workshops.RDS\")\nworkshop_breakdown <- readRDS(file = \"data/workshop_breakdown.RDS\")\n\nWe’ll complete the following tasks:\n\nCreate a basic bar chart comparing workshop attendance among the various schools.\nCreate a grouped bar chart comparing workshop attendance among the schools and university roles.\nAdd titles and labels to our graph\nAdjust the color palette\nChoose a theme\n\nLet’s open a new script and load the libraries we’ll be working with in this lesson:\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "Week03/week03_lesson.html#ggplot2-basics",
    "href": "Week03/week03_lesson.html#ggplot2-basics",
    "title": "R Community of Practice Week 3",
    "section": "ggplot2 Basics",
    "text": "ggplot2 Basics\nAll ggplot2 graphs start with the same basic template:\n<DATA> %>%\n    ggplot(aes(<MAPPINGS>)) +\n    <GEOM_FUNCTION>() +\n    <Additional GEOMS, SCALES, THEMES, etc. . . >\n\nAll graphs start with the ggplot function and the data. We’ll use the pipe to pipe the data to the function.\n\nall_workshops %>% \n  ggplot()\n\n\n\n\nWe see that even this initializes the plot area of RStudio."
  },
  {
    "objectID": "Week03/week03_lesson.html#building-a-basic-bar-chart",
    "href": "Week03/week03_lesson.html#building-a-basic-bar-chart",
    "title": "R Community of Practice Week 3",
    "section": "Building a basic bar chart",
    "text": "Building a basic bar chart\nNext, we define a mapping (using the aesthetic, or aes(), function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, color, etc. Here we will say that the x axis should contain the affiliation variable. Note how the x-axis populates with some numbers and tick marks. We do not need to specify a y variable, since it will look at the count by default.\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation))\n\n\n\n\nNext we need to add ‘geoms’ – graphical representations of the data in the plot (points, lines, bars). ggplot2 offers many different geoms for common graph types. To add a geom to the plot use the + operator.\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation)) +\n  geom_bar()\n\n\n\n\nBy default bar graphs will display the count of the x variable, but it is also possible to specify a y variable that contains the count, as we do in our summarized dataset workshop_breakdown.\nIn this case, we would want to be able to specify affiliation as the x variable and n as the y variable.\n\nworkshop_breakdown %>% \n  ggplot(mapping = aes(x=affiliation, y=n)) +\n  geom_bar(stat=\"identity\")\n\n\n\n\nYou need to make one other adjustment, and change the stat argument from it’s default of “count” to “identity” This tells it to base the y axis on the specified variable."
  },
  {
    "objectID": "Week03/week03_lesson.html#geom-specifications",
    "href": "Week03/week03_lesson.html#geom-specifications",
    "title": "R Community of Practice Week 3",
    "section": "geom specifications",
    "text": "geom specifications\nAll geoms have certain attributes that can be modified. Polygons like bars, have the properties fill and color. You can change the inside color of a bar with fill, and the outside with color.\nIf we want to change the color of a bar, we can use the fill and color arguments in the geom_bar layer.\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation)) +\n  geom_bar(fill=\"blue\", color=\"black\")\n\n\n\n\nR has several built in color names. You can see them by calling the function colors(). You can also specify colors using rgb and hexadecimal codes.\nAn important concept when working with ggplot is the idea of aesthetic mapping. We used the aes function to map the x and y axis to variables. We could also do this to assign color and fill to our bars.\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation)) +\n  geom_bar(aes(fill=affiliation))\n\n\n\n\nNow a different color from the default ggplot palette is mapped to each level of our affiliation variable."
  },
  {
    "objectID": "Week03/week03_lesson.html#reordering-bars",
    "href": "Week03/week03_lesson.html#reordering-bars",
    "title": "R Community of Practice Week 3",
    "section": "Reordering Bars",
    "text": "Reordering Bars\nBy default our graph was ordered alphabetically by level, but it is often helpful to sort the bars numerically. We can do this with the reorder function.\n\nall_workshops %>% \n  ggplot(mapping = aes(x=forcats::fct_infreq(affiliation))) +\n  geom_bar()"
  },
  {
    "objectID": "Week03/week03_lesson.html#grouped-bar-charts",
    "href": "Week03/week03_lesson.html#grouped-bar-charts",
    "title": "R Community of Practice Week 3",
    "section": "Grouped bar charts",
    "text": "Grouped bar charts\nWhat if we want to compare affiliation and status? To do this we can create a grouped bar chart by mapping fill to the status variable.\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation, fill=status)) +\n  geom_bar()\n\n\n\n\nBy default this creates a stacked bar chart. To make it grouped, we add a position=\"dodged\" argument to geom_bar()\n\nall_workshops %>% \n  ggplot(mapping=aes(x=fct_infreq(affiliation), fill=status)) +\n  geom_bar(position = \"dodge\", width =0.75)"
  },
  {
    "objectID": "Week03/week03_lesson.html#working-with-color-palettes",
    "href": "Week03/week03_lesson.html#working-with-color-palettes",
    "title": "R Community of Practice Week 3",
    "section": "Working with color palettes",
    "text": "Working with color palettes\nThere are many options for changing the color palette of your plot. You can set your palette manually:\n\nmyPalette <- c(\"#C8102E\", \"#FFCD00\", \"#2C2A29\")\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation, fill=status)) +\n  geom_bar(position = \"dodge\", width =0.75) + \n  labs(title = \"Who is attending library workshops?\", \n       subtitle = \"Attendance by School and Role, 2018-2023\", \n       x=\"School Affiliation\", y= \"Number of Attendees\", \n       fill=\"University Role\") + \n  scale_fill_manual(values = myPalette)\n\n\n\n\nGenerally, it may be preferable to work with one of the built in ggplot2 or R palettes, or to install one of several packages with additional palettes such as:\n\nRColorBrewer\nviridis\nggthemes\nggsci\nwesanderson\n\nLet’s try applying a viridis palette. viridis was designed to be especially robust for many forms of color-blindness. It is also meant to print well in grey scale. As an additional advantage, a lightweight form of the package is included with ggplot2, so there is no need to install additional packages.\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation, fill=status)) +\n  geom_bar(position = \"dodge\", width = 0.75) + \n  labs(title = \"Who is attending library workshops?\", \n       subtitle = \"Attendance by School and Role, 2018-2023\", \n       x=\"School Affiliation\", \n       y= \"Number of Attendees\",\n       fill=\"University Role\") +\n  scale_fill_viridis_d()\n\n\n\n\nLearn more from the viridis documentation"
  },
  {
    "objectID": "Week03/week03_lesson.html#adding-titles-and-axis-labels",
    "href": "Week03/week03_lesson.html#adding-titles-and-axis-labels",
    "title": "R Community of Practice Week 3",
    "section": "Adding titles and axis labels",
    "text": "Adding titles and axis labels\nA good plot communicates clearly. So far we’ve talked about achieving this through the aesthetic aspects of your plot, but it’s important to make sure your graph has a clear title and axis labels as well. There are a few ways to do this in ggplot2, but one of the simplest is to use the labs() function.\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation, fill=status)) +\n  geom_bar(position = \"dodge\", width = 0.75) + \n  labs(title = \"Who is attending library workshops?\", \n       subtitle = \"Attendance by School and Role, 2018-2023\", \n       x=\"School Affiliation\", \n       y= \"Number of Attendees\",\n       fill=\"University Role\")"
  },
  {
    "objectID": "Week03/week03_lesson.html#changing-the-theme",
    "href": "Week03/week03_lesson.html#changing-the-theme",
    "title": "R Community of Practice Week 3",
    "section": "Changing the theme",
    "text": "Changing the theme\nThe theme of a ggplot2 graph controls the overall look and all non-data elements of the plot. There are several built-in themes which can be applied as another layer. Start typing theme_ in RStudio to see a list of themes. You can also use the theme() function to modify aspects of an existing theme. Here we apply theme_classic() which removes the grid lines and grey background of the default theme.\n\nall_workshops %>% \n  ggplot(mapping=aes(x=fct_infreq(affiliation), fill=status)) +\n  geom_bar(position = \"dodge\", width = 0.75) + \n  labs(title = \"Who is attending library workshops?\", \n       subtitle = \"Attendance by School and Role, 2018-2023\", \n       x=\"School Affiliation\", \n       y= \"Number of Attendees\",\n       fill=\"University Role\") +\n  scale_fill_viridis_d() +\n  theme_classic()"
  },
  {
    "objectID": "Week03/week03_lesson.html#helpful-resources",
    "href": "Week03/week03_lesson.html#helpful-resources",
    "title": "R Community of Practice Week 3",
    "section": "Helpful Resources",
    "text": "Helpful Resources\n\nBackground and Overview\n\nggplot2 documentation\nR for Data Science\n\nChapter 3, “Data Visualization”\nChapter 28, “Graphics for Communication”\n\n\n\n\nTutorials for Many Kinds of Plots\n\nR Graph Gallery\nR Graphics Cookbook\n\n\n\nWorking with Color and Other Aesthetics\n\nR Graph Gallery Color Section\nPaletteer package\nggplot2 Aesthetic Specifications"
  },
  {
    "objectID": "Week03/week03_lesson.html#setting-vs-mapping-aesthetics",
    "href": "Week03/week03_lesson.html#setting-vs-mapping-aesthetics",
    "title": "R Community of Practice Week 3",
    "section": "Setting vs mapping aesthetics",
    "text": "Setting vs mapping aesthetics\nWhen working with ggplot2, it’s important to understand the difference between setting aesthetic properties and mapping them. All geoms have certain visual attributes that can be modified. Polygons like bars, have the properties fill and color. You can change the inside color of a bar with fill, and the border with color. We can modify the defaults with the fill and color arguments in the geom_bar() layer. (I’ve also increased the linewidth to make it easier to see the border color)\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation)) +\n  geom_bar(fill=\"blue\", color=\"purple\", linewidth=1.5)\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nHow did we know the color names “blue” and “purple” would work in the code above? R has 657 (!!) built in color names. You can see them by calling the function colors(). You can also specify colors using rgb and hexadecimal codes.\n\n\nNow we have manually set a value for the fill and color. To create our initial graph, we used the mapping argument and the aes() function to map the x axis to the affiliation variable. Watch what happens if we map the fill property to the affiliation variable as well.\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation, fill=affiliation)) +\n  geom_bar()"
  },
  {
    "objectID": "Week03/week03_lesson.html#building-a-grouped-bar-chart",
    "href": "Week03/week03_lesson.html#building-a-grouped-bar-chart",
    "title": "R Community of Practice Week 3",
    "section": "Building a grouped bar chart",
    "text": "Building a grouped bar chart\nMapping a variable to an aesthetic is especially useful when we have third variable we want to express on our graph. For example, what if we want to compare attendance by both affiliation and status? To do this we can create a grouped bar chart by mapping fill to the status variable.\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation, fill=status)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen you map an aesthetic with aes() in the ggplot() function it is inherited by all subsequent layers. When you map in a geom_*() function it is applied only to that layer.\n\n\nBy default this creates a stacked bar chart. To make it grouped, we add a position=\"dodged\" argument to geom_bar()\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation, fill=status)) + \n  geom_bar(position = \"dodge\")\n\n\n\n\nTo make our graph look less crowded, we can also modify the width of the bars. Note this is done outside of the aes() function.\n\nall_workshops %>% \n  ggplot(mapping=aes(x=affiliation, fill=status)) +\n  geom_bar(position = \"dodge\", width = 0.75)"
  }
]